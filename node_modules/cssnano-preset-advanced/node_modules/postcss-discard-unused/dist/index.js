'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _uniqs = require('uniqs');

var _uniqs2 = _interopRequireDefault(_uniqs);

var _postcss = require('postcss');

var _postcssSelectorParser = require('postcss-selector-parser');

var _postcssSelectorParser2 = _interopRequireDefault(_postcssSelectorParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var comma = _postcss.list.comma,
    space = _postcss.list.space;


var atrule = 'atrule';
var decl = 'decl';
var rule = 'rule';

function addValues(cache, _ref) {
    var value = _ref.value;

    return comma(value).reduce(function (memo, val) {
        return [].concat(_toConsumableArray(memo), _toConsumableArray(space(val)));
    }, cache);
}

function filterAtRule(_ref2) {
    var atRules = _ref2.atRules,
        values = _ref2.values;

    values = (0, _uniqs2.default)(values);
    atRules.forEach(function (node) {
        var hasAtRule = values.some(function (value) {
            return value === node.params;
        });
        if (!hasAtRule) {
            node.remove();
        }
    });
}

function filterNamespace(_ref3) {
    var atRules = _ref3.atRules,
        rules = _ref3.rules;

    rules = (0, _uniqs2.default)(rules);
    atRules.forEach(function (atRule) {
        var _atRule$params$split$ = atRule.params.split(' ').filter(Boolean),
            param = _atRule$params$split$[0],
            len = _atRule$params$split$.length;

        if (len === 1) {
            return;
        }
        var hasRule = rules.some(function (r) {
            return r === param || r === '*';
        });
        if (!hasRule) {
            atRule.remove();
        }
    });
}

function hasFont(fontFamily, cache) {
    return comma(fontFamily).some(function (font) {
        return cache.some(function (c) {
            return ~c.indexOf(font);
        });
    });
}

// fonts have slightly different logic
function filterFont(_ref4) {
    var atRules = _ref4.atRules,
        values = _ref4.values;

    values = (0, _uniqs2.default)(values);
    atRules.forEach(function (r) {
        var families = r.nodes.filter(function (_ref5) {
            var prop = _ref5.prop;
            return prop === 'font-family';
        });
        // Discard the @font-face if it has no font-family
        if (!families.length) {
            return r.remove();
        }
        families.forEach(function (family) {
            if (!hasFont(family.value.toLowerCase(), values)) {
                r.remove();
            }
        });
    });
}

exports.default = (0, _postcss.plugin)('postcss-discard-unused', function (opts) {
    var _Object$assign = Object.assign({}, {
        fontFace: true,
        counterStyle: true,
        keyframes: true,
        namespace: true
    }, opts),
        fontFace = _Object$assign.fontFace,
        counterStyle = _Object$assign.counterStyle,
        keyframes = _Object$assign.keyframes,
        namespace = _Object$assign.namespace;

    return function (css) {
        var counterStyleCache = { atRules: [], values: [] };
        var keyframesCache = { atRules: [], values: [] };
        var namespaceCache = { atRules: [], rules: [] };
        var fontCache = { atRules: [], values: [] };
        css.walk(function (node) {
            var type = node.type,
                prop = node.prop,
                selector = node.selector,
                name = node.name;

            if (type === rule && namespace && ~selector.indexOf('|')) {
                if (~selector.indexOf('[')) {
                    // Attribute selector, so we should parse further.
                    (0, _postcssSelectorParser2.default)(function (ast) {
                        ast.walkAttributes(function (_ref6) {
                            var ns = _ref6.namespace;

                            namespaceCache.rules = namespaceCache.rules.concat(ns);
                        });
                    }).process(selector);
                } else {
                    // Use a simple split function for the namespace
                    namespaceCache.rules = namespaceCache.rules.concat(selector.split('|')[0]);
                }
                return;
            }
            if (type === decl) {
                if (counterStyle && /list-style|system/.test(prop)) {
                    counterStyleCache.values = addValues(counterStyleCache.values, node);
                }
                if (fontFace && node.parent.type === rule && /font(|-family)/.test(prop)) {
                    fontCache.values = fontCache.values.concat(comma(node.value.toLowerCase()));
                }
                if (keyframes && /animation/.test(prop)) {
                    keyframesCache.values = addValues(keyframesCache.values, node);
                }
                return;
            }
            if (type === atrule) {
                if (counterStyle && /counter-style/.test(name)) {
                    counterStyleCache.atRules.push(node);
                }
                if (fontFace && name === 'font-face' && node.nodes) {
                    fontCache.atRules.push(node);
                }
                if (keyframes && /keyframes/.test(name)) {
                    keyframesCache.atRules.push(node);
                }
                if (namespace && name === 'namespace') {
                    namespaceCache.atRules.push(node);
                }
                return;
            }
        });
        counterStyle && filterAtRule(counterStyleCache);
        fontFace && filterFont(fontCache);
        keyframes && filterAtRule(keyframesCache);
        namespace && filterNamespace(namespaceCache);
    };
});
module.exports = exports['default'];